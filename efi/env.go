// -*- Mode: Go; indent-tabs-mode: t -*-

/*
 * Copyright (C) 2019-2023 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

package efi

import (
	"bytes"
	"crypto"
	"crypto/sha1"
	"encoding/binary"
	"io"
	"sort"

	efi "github.com/canonical/go-efilib"
	"github.com/canonical/tcglog-parser"
	"golang.org/x/xerrors"
)

// HostEnvironment is an interface that abstracts out an EFI environment, so that
// consumers of the API can provide a custom mechanism to read EFI variables or parse
// the TCG event log.
type HostEnvironment interface {
	// ReadVar reads the specified EFI variable
	ReadVar(name string, guid efi.GUID) ([]byte, efi.VariableAttributes, error)

	// ReadEventLog reads the TCG event log
	ReadEventLog() (*tcglog.Log, error)
}

// varReader is a subset of HostEnvironment that is just for EFI variables
type varReader interface {
	// ReadVar reads the specified EFI variable
	ReadVar(name string, guid efi.GUID) ([]byte, efi.VariableAttributes, error)
}

// rootVarReaderKey is a SHA1 used to uniquely identify the contents of a rootVarReader.
// This is to ensure that we don't generate multiple profile branches with the same
// starting state.
type rootVarReaderKey [sha1.Size]byte

type varContents struct {
	attrs efi.VariableAttributes
	data  []byte
}

// rootVarReader provides the initial state for each profile generation branch. It
// consists of the host environment and updates that have been generated by previous
// iterations of the profile generation.
type rootVarReader struct {
	host      varReader
	overrides map[efi.VariableDescriptor]varContents
}

// ReadVar implements varReader.ReadVar
func (r *rootVarReader) ReadVar(name string, guid efi.GUID) ([]byte, efi.VariableAttributes, error) {
	override, exists := r.overrides[efi.VariableDescriptor{Name: name, GUID: guid}]
	if exists {
		return override.data, override.attrs, nil
	}
	return r.host.ReadVar(name, guid)
}

// Key returns the unique key for this reader, and is based on the set of updates on the
// original host environment. This is used to track which initial states have been handled
// already for a profile.
func (r *rootVarReader) Key() rootVarReaderKey {
	// Ensure that this is stable by building an ordered list
	var descs []efi.VariableDescriptor
	for desc := range r.overrides {
		descs = append(descs, desc)
	}
	sort.Slice(descs, func(i, j int) bool {
		return bytes.Compare(descs[i].GUID[:], descs[j].GUID[:]) < 0 || descs[i].Name < descs[j].Name
	})

	// Start with an empty key which corresponds to the original
	// host environment.
	var key rootVarReaderKey

	for _, desc := range descs {
		override := r.overrides[desc]

		h := crypto.SHA1.New()
		h.Write(key[:])
		h.Write(desc.GUID[:])
		binary.Write(h, binary.LittleEndian, uint64(len(desc.Name)))
		binary.Write(h, binary.LittleEndian, uint64(len(override.data)))
		io.WriteString(h, desc.Name)
		h.Write(override.data)

		copy(key[:], h.Sum(nil))
	}

	return key
}

// Copy returns a copy of this rootVarReader.
func (r *rootVarReader) Copy() *rootVarReader {
	out := &rootVarReader{
		host:      r.host,
		overrides: make(map[efi.VariableDescriptor]varContents)}
	for k, v := range r.overrides {
		out.overrides[k] = v
	}
	return out
}

// ApplyUpdates applies the specified sequence of updates to this rootVarReader.
func (r *rootVarReader) ApplyUpdates(updates *varUpdate) error {
	// arrange in order of application from oldest to newest
	var updateSlice []*varUpdate
	for ; updates != nil; updates = updates.previous {
		updateSlice = append([]*varUpdate{updates}, updateSlice...)
	}

	for _, update := range updateSlice {
		r.overrides[update.name] = varContents{attrs: update.attrs, data: update.data}
		origData, _, err := r.host.ReadVar(update.name.Name, update.name.GUID)
		switch {
		case err == efi.ErrVarNotExist:
			// ok
		case err != nil:
			return err
		case bytes.Equal(update.data, origData):
			// drop this override if it matches the original data
			delete(r.overrides, update.name)
		}
	}

	return nil
}

// varUpdate is the sequence of updates generated by a profile branch, associated with
// a varBranchState.
type varUpdate struct {
	previous *varUpdate
	name     efi.VariableDescriptor
	attrs    efi.VariableAttributes
	data     []byte
}

type varReadWriter interface {
	varReader

	// WriteVar updates the specified EFI variable.
	WriteVar(name string, guid efi.GUID, attrs efi.VariableAttributes, data []byte) error
}

// varBranchState corresponds to a EFI variable state associated with a profile branch,
// consisting of an initial starting environment and a sequence of updates that have been
// added during profile generation. Each profile generation loop starts with one of these
// without any updates. Branches in a profile inherit a copy of this from the parent branch
// and may make modifications to EFI variables (eg, applying a SBAT update) which may affect
// other branches - in this case, the profile generation may be re-executed multiple times
// with different starting states as a result of these updates. These starting states are
// computed by the assocated rootVarsCollector.
type varBranchState struct {
	initial   *rootVarReader // the initial starting environment
	updates   *varUpdate     // the updates applied by the associated branch
	collector *rootVarsCollector
}

func newVarBranchState(initial *rootVarReader, collector *rootVarsCollector) *varBranchState {
	return &varBranchState{initial: initial, collector: collector}
}

// ReadVar implements varReader.ReadVar.
func (s *varBranchState) ReadVar(name string, guid efi.GUID) ([]byte, efi.VariableAttributes, error) {
	update := s.updates
	for ; update != nil; update = update.previous {
		desc := efi.VariableDescriptor{Name: name, GUID: guid}
		if update.name == desc {
			return update.data, update.attrs, nil
		}
	}
	return s.initial.ReadVar(name, guid)
}

// WriteVar implements varReadWriter.WriteVar.
func (s *varBranchState) WriteVar(name string, guid efi.GUID, attrs efi.VariableAttributes, data []byte) error {
	orig, _, err := s.ReadVar(name, guid)
	switch {
	case err == efi.ErrVarNotExist:
		// ok
	case err != nil:
		return err
	}

	if attrs&efi.AttributeAppendWrite != 0 {
		data = append(orig, data...)
	}

	s.updates = &varUpdate{
		previous: s.updates,
		name:     efi.VariableDescriptor{Name: name, GUID: guid},
		attrs:    attrs &^ efi.AttributeAppendWrite,
		data:     data}
	s.collector.registerUpdatesFor(s.initial, s.updates)
	return nil
}

// rootVarsCollector keeps track of all of the starting EFI variable states that
// a profile needs to be generated against. The profile generation runs an outer
// loop that adds a branch for each of the starting states. Profile generation may
// add more starting states as some branches have paths that update EFI variables
// (such as applying SBAT updates) which may have an effect on other branches.
type rootVarsCollector struct {
	host varReader // the externally supplied host environment

	// pendingUpdates contains a record of updates that are generated by a
	// profile and which haven't been processed yet. When there are no more
	// starting states to process (todo is empty), this field is consumed
	// in order to try to build more starting states.
	//
	// This field is keyed by the initial state for the branch that applied
	// an update.
	pendingUpdates map[*rootVarReader][]*varUpdate

	seen map[rootVarReaderKey]struct{} // known starting states

	// todo contains a list of starting states that a profile branch still
	// needs to be generated for. When this is empty, pendingUpdates is
	// drained in order to try to create more.
	todo []*rootVarReader

	err error
}

func newRootVarsCollector(vars varReader) *rootVarsCollector {
	return &rootVarsCollector{
		host:           vars,
		pendingUpdates: make(map[*rootVarReader][]*varUpdate),
		seen:           map[rootVarReaderKey]struct{}{rootVarReaderKey{}: struct{}{}}, // add the current environment
		todo: []*rootVarReader{
			&rootVarReader{
				host:      vars,
				overrides: make(map[efi.VariableDescriptor]varContents)}}} // add the current environment
}

// registerUpdateFor is called when a branch updates an EFI variable. This will
// queue new starting states to process if the updated state hasn't already been
// processed. This should be called on every update - this ensures that if a branch
// makes more than one update, the generated profile will be valid for intermediate
// states.
func (c *rootVarsCollector) registerUpdatesFor(initial *rootVarReader, updates *varUpdate) {
	c.pendingUpdates[initial] = append(c.pendingUpdates[initial], updates)
}

func (c *rootVarsCollector) setErr(err error) {
	c.err = err
	c.todo = nil
}

// Root returns a rootVarReader corresponding to the supplied HostEnvironment.
func (c *rootVarsCollector) Root() *rootVarReader {
	return &rootVarReader{host: c.host}
}

// collectTodo tries to fill the todo field with more starting states if it is
// empty. It does this by processing the list of updates in the pendingUpdates
// field, building new starting state and verifying that they are states we
// haven't seen before.
func (c *rootVarsCollector) collectTodo() {
	if len(c.todo) > 0 || c.err != nil {
		return
	}

	for root, updates := range c.pendingUpdates {
		for _, updateList := range updates {
			newRoot := root.Copy()
			if err := newRoot.ApplyUpdates(updateList); err != nil {
				c.setErr(xerrors.Errorf("cannot compute new starting using updates from a previous profile branch: %w", err))
				return
			}
			key := newRoot.Key()
			if _, exists := c.seen[key]; exists {
				// we've already generated a branch for this starting state
				continue
			}
			c.seen[key] = struct{}{}
			c.todo = append(c.todo, newRoot)

		}
		delete(c.pendingUpdates, root)
	}
}

// More indicates that there are more starting states to generate profile
// branches for. When this returns false, the caller should make sure an
// error didn't occur by calling Err().
func (c *rootVarsCollector) More() bool {
	c.collectTodo()
	return len(c.todo) > 0
}

// Next returns the next rootVarReader to generate a profile branch for. This will
// not return the same starting state more than once.
func (c *rootVarsCollector) Next() *rootVarReader {
	c.collectTodo()
	next := c.todo[0]
	c.todo = c.todo[1:]
	return next
}

// Err returns an error if one occurred.
func (c *rootVarsCollector) Err() error {
	return c.err
}
